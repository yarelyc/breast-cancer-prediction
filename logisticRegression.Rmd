
---
title: "Predicting Breast Cancer using Logistic Regression"
author: "Yarely Chino"
date: "May 9, 2017"
output: html_document
---

<!-- Note: echo=TRUE to show code -->
```{r global_options, include=FALSE}
knitr::opts_chunk$set(prompt=TRUE, comment="", echo=TRUE)
```

<!-- Random seed -->
```{r}
set.seed(127)
```

Include sources
```{r}
library(rpart)
library(rpart.plot)
source("/Users/yarelychino/Downloads/lin-regr-util.R")
source("/Users/yarelychino/Downloads/class-util.R")

```

##Reading and preprocessing the data set

```{r}
dat = read.csv("/Users/yarelychino/Desktop/breast-cancer-prediction/data.csv")
dat$X = NULL
dat$output = ifelse(dat$diagnosis == "M", 1, 0)

```


### Split dataset into training set and testing set
```{r}

splits = sample(1:nrow(dat), floor(0.80 * nrow(dat)))
tr_dat = dat[splits,]
te_dat = dat[-splits,]

```


```{r}
predict_by = function(name){
  plot(dat$output ~ dat$element, col="red4", pch = 16, ylab = "probability", xlab = name, main=paste0("Breast cancer probability using ", name))
  fit = glm(output ~ element, data=dat, family=binomial )
  bp = data.frame(element=seq(range(dat$element)[1],range(dat$element)[2], length.out=50))
  probs = predict(fit, newdata=bp, type="response")
  lines(bp$element, probs, lty=2, col = "blue")
}

```

####Logistic function using radius worst
```{r}
dat$element = dat$radius_worst
predict_by("radius worst")

```


####Logistic function using area standard error
```{r}
dat$element = dat$area_se
predict_by("area standard error")

```

##Model for Logistic Regression

```{r}
fit = glm(output ~ radius_worst + area_worst + smoothness_worst, dat=tr_dat, family=binomial)
summary(fit)

```

###Predictions

Confusion Matrix 
```{r}
pred = predict(fit, newdata=te_dat, type="response")
predicts = as.numeric(pred > 0.5)
actuals = te_dat$output
conf_mtx = table(predicts, actuals)
conf_mtx

```
Accuracy
```{r}
mean(predicts == actuals)
```

Classifier's Precision

```{r}
conf_mtx[2,2] / (conf_mtx[2,2] + conf_mtx[1,2])
```

Classifier's Recall

```{r}
conf_mtx[2,2] / (conf_mtx[2,2] + conf_mtx[2,1])
```

```{r}

te_errs = c()
tr_errs = c()
te_actual = te_dat$output

tr_sizes = seq(100, nrow(tr_dat), length.out=10)

for (tr_size in tr_sizes) {
  tr_dat1 = tr_dat[1:tr_size,]
  tr_actual = tr_dat1$output
  
  #creating model using tr_dat1
  fit = glm(output ~ radius_worst + area_worst + smoothness_worst, dat=tr_dat1, family=binomial)
  
  # error on training set
  tr_predicted = predict(fit, tr_dat1, type="response")
  tr_predicted = as.numeric(tr_predicted > 0.5)
  err = sum(tr_actual != tr_predicted)/length(tr_predicted)
  tr_errs = c(tr_errs, err)
  
  # error on test set
  te_predicted = predict(fit, te_dat, type="response")
  te_predicted = as.numeric(te_predicted > 0.5)
  err = sum(te_actual != te_predicted)/length(te_predicted)
  te_errs = c(te_errs, err)
}
 plot(tr_sizes, te_errs, type="l", col="red4", ylim=range(c(te_errs,tr_errs)), xlab="Size", ylab="Error", main="Learning Curve for Logistic Regression")
 lines(tr_sizes, tr_errs, col="blue")
legend(range(c(te_errs,tr_errs))[2], x = 385, legend = c("training errors", "testing errors"), col = c("blue", "red4"), pch="|",  cex = .8)

```

```{r}
prec_recall_summary = function(predicts, actuals) {
   thresh = seq(0, 1, length.out=50)
   prec_rec = data.frame()
   actuals = factor(as.numeric(actuals))
   for (th in thresh) {
     predicts = factor(as.numeric(pred >= th), levels=c("0","1"))
     prec_rec = rbind(prec_rec, as.vector(table(predicts, actuals)))
   }
   names(prec_rec) = c("TN", "FP", "FN", "TP")
   prec_rec$threshold = thresh
   prec_rec$precision = prec_rec$TP/(prec_rec$TP + prec_rec$FP)
   prec_rec$recall    = prec_rec$TP/(prec_rec$TP + prec_rec$FN)
   prec_rec$false_pos = prec_rec$FP/(prec_rec$FP + prec_rec$TN)
   return(prec_rec)
 }
 prec_rec = prec_recall_summary(predicts, actuals)

```



####Plots show precision and recall 

```{r}
par(mfrow=c(2,1))
plot(prec_rec$threshold, prec_rec$precision, col = "red4", type = "l", xlab = "threshold", ylab = "precision" )
grid(col="grey60")
plot(prec_rec$threshold, prec_rec$recall, col = "red4", type = "l", xlab = "threshold", ylab = "recall" )
grid(col="grey60")

```

####Receiver Operating Character Graph

```{r}

prec_rec$true_pos = prec_rec$TP / (prec_rec$TP + prec_rec$FN)
plot( prec_rec$false_pos, prec_rec$true_pos, col = "red4", type = "l", xlab = "True positive rate", ylab = "False positive rate" , main= "ROC")
grid(col="grey60")
```


